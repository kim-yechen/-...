<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Workflow Canvas</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React & ReactDOM CDN -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel CDN for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Lucide Icons CDN -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Pretendard:wght@400;600;700;900&display=swap');
        body { 
            font-family: 'Pretendard', sans-serif; 
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #f8fafc;
            user-select: none;
        }
        .glass-card { 
            background: rgba(255, 255, 255, 0.9); 
            backdrop-filter: blur(10px); 
            border: 1px solid rgba(226, 232, 240, 0.8); 
        }
        .node-glow { transition: box-shadow 0.3s ease, transform 0.2s ease; }
        .node-glow:hover { 
            box-shadow: 0 10px 25px -5px rgba(79, 70, 229, 0.2); 
        }
        .btn-action:active { transform: scale(0.95); }
        /* Custom scrollbar */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #f1f5f9; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
        
        .connection-line {
            stroke-dasharray: 8;
            animation: dash 30s linear infinite;
        }
        @keyframes dash {
            to { stroke-dashoffset: -1000; }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect, useMemo, useCallback } = React;
        
        // Lucide Icon Component Wrapper
        const Icon = ({ name, size = 18, className = "", fill = "none" }) => {
            const iconRef = useRef(null);
            useEffect(() => {
                if (window.lucide && window.lucide.icons[name]) {
                    const iconElement = window.lucide.icons[name].toSvg({ 
                        size, 
                        class: className,
                        fill: fill
                    });
                    if (iconRef.current) iconRef.current.innerHTML = iconElement;
                }
            }, [name, size, className, fill]);
            return <span ref={iconRef} className="inline-flex items-center justify-center" />;
        };

        const App = () => {
            // 프로젝트 상태
            const [nodes, setNodes] = useState([
                { id: 'n1', type: 'Input', x: 100, y: 200, content: '여기에 명령어를 입력하세요.', status: 'idle' },
                { id: 'n2', type: 'Output', x: 500, y: 200, content: '결과가 여기에 표시됩니다.', status: 'idle' },
            ]);
            const [connections, setConnections] = useState([{ from: 'n1', to: 'n2' }]);

            // 설정 및 UI 상태
            const [apiKey, setApiKey] = useState(localStorage.getItem('gemini_api_key') || '');
            const [showApiSettings, setShowApiSettings] = useState(false);
            const [isAiLoading, setIsAiLoading] = useState(false);
            
            // 드래그 및 연결 로직 상태
            const [isDragging, setIsDragging] = useState(false);
            const [draggedId, setDraggedId] = useState(null);
            const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
            const [connectionSource, setConnectionSource] = useState(null);

            // 곡선 경로 계산
            const getCurvePath = (startX, startY, endX, endY) => {
                const dx = Math.abs(endX - startX);
                const offset = Math.max(dx / 2, 50);
                return `M ${startX} ${startY} C ${startX + offset} ${startY}, ${endX - offset} ${endY}, ${endX} ${endY}`;
            };

            // 드래그 시작
            const onMouseDown = (e, id) => {
                if (e.target.closest('.btn-action') || e.target.closest('textarea')) return;
                const node = nodes.find(n => n.id === id);
                if (node) {
                    setIsDragging(true);
                    setDraggedId(id);
                    setDragOffset({ x: e.clientX - node.x, y: e.clientY - node.y });
                }
            };

            // 드래그 중
            const onMouseMove = (e) => {
                if (isDragging && draggedId) {
                    setNodes(prev => prev.map(n => 
                        n.id === draggedId ? { ...n, x: e.clientX - dragOffset.x, y: e.clientY - dragOffset.y } : n
                    ));
                }
            };

            // 드래그 종료
            const onMouseUp = () => {
                setIsDragging(false);
                setDraggedId(null);
            };

            // 연결 로직
            const handleNodeClick = (id) => {
                if (connectionSource) {
                    if (connectionSource !== id) {
                        // 이미 연결되어 있는지 확인
                        const exists = connections.find(c => c.from === connectionSource && c.to === id);
                        if (exists) {
                            setConnections(prev => prev.filter(c => !(c.from === connectionSource && c.to === id)));
                        } else {
                            setConnections(prev => [...prev, { from: connectionSource, to: id }]);
                        }
                    }
                    setConnectionSource(null);
                }
            };

            // Gemini API 실행
            const runGemini = async (nodeId) => {
                if (!apiKey) {
                    setShowApiSettings(true);
                    return;
                }

                const node = nodes.find(n => n.id === nodeId);
                setIsAiLoading(true);
                updateNodeStatus(nodeId, 'processing');

                try {
                    const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ contents: [{ parts: [{ text: node.content }] }] })
                    });
                    const data = await res.json();
                    if (data.error) throw new Error(data.error.message);

                    const resultText = data.candidates?.[0]?.content?.parts?.[0]?.text || "결과를 가져오지 못했습니다.";

                    // 연결된 모든 노드에 결과 전달
                    const targets = connections.filter(c => c.from === nodeId).map(c => c.to);
                    targets.forEach(targetId => {
                        updateNodeContent(targetId, resultText);
                        updateNodeStatus(targetId, 'completed');
                    });
                    updateNodeStatus(nodeId, 'completed');
                } catch (e) {
                    alert(`오류: ${e.message}`);
                    updateNodeStatus(nodeId, 'idle');
                } finally {
                    setIsAiLoading(false);
                }
            };

            const updateNodeContent = (id, content) => {
                setNodes(prev => prev.map(n => n.id === id ? { ...n, content } : n));
            };

            const updateNodeStatus = (id, status) => {
                setNodes(prev => prev.map(n => n.id === id ? { ...n, status } : n));
            };

            const addNode = () => {
                const newId = `n-${Date.now()}`;
                setNodes(prev => [...prev, { id: newId, type: 'Output', x: 100, y: 100, content: '새 블록', status: 'idle' }]);
            };

            return (
                <div className="h-screen w-full flex flex-col overflow-hidden" onMouseMove={onMouseMove} onMouseUp={onMouseUp}>
                    {/* API 설정 모달 */}
                    {showApiSettings && (
                        <div className="fixed inset-0 bg-slate-900/60 z-[100] flex items-center justify-center backdrop-blur-sm p-4">
                            <div className="bg-white rounded-[2.5rem] p-8 w-full max-w-md shadow-2xl border border-white animate-in zoom-in-95 duration-200">
                                <div className="flex justify-between items-center mb-6">
                                    <h2 className="text-xl font-bold flex items-center gap-2"><Icon name="Settings" className="text-indigo-600"/> API 설정</h2>
                                    <button onClick={() => setShowApiSettings(false)} className="p-2 hover:bg-slate-100 rounded-full transition-all"><Icon name="X" size={20} /></button>
                                </div>
                                <input 
                                    type="password"
                                    className="w-full p-4 bg-slate-50 border-2 border-slate-100 rounded-2xl mb-6 outline-none focus:border-indigo-500 focus:bg-white transition-all font-mono"
                                    placeholder="Gemini API Key (AIzaSy...)"
                                    value={apiKey}
                                    onChange={(e) => {
                                        setApiKey(e.target.value);
                                        localStorage.setItem('gemini_api_key', e.target.value);
                                    }}
                                />
                                <button onClick={() => setShowApiSettings(false)} className="w-full bg-indigo-600 text-white py-4 rounded-2xl font-bold shadow-lg hover:bg-indigo-700 transition-all active:scale-95">저장</button>
                            </div>
                        </div>
                    )}

                    {/* 헤더 */}
                    <header className="bg-white/80 backdrop-blur-md border-b px-6 py-4 flex justify-between items-center z-20 shadow-sm">
                        <div className="flex items-center gap-3">
                            <div className="bg-indigo-600 p-2 rounded-xl text-white shadow-lg"><Icon name="Zap" size={22} fill="white" /></div>
                            <h1 className="text-xl font-black tracking-tight text-slate-800 uppercase">AI Workflow</h1>
                        </div>
                        <div className="flex items-center gap-4">
                            {connectionSource && <div className="text-xs font-bold text-amber-600 animate-pulse bg-amber-50 px-3 py-1.5 rounded-full border border-amber-100">연결할 대상을 클릭하세요...</div>}
                            <button onClick={() => setShowApiSettings(true)} className="p-2.5 hover:bg-slate-100 rounded-xl transition-all text-slate-400 hover:text-indigo-600 border border-transparent hover:border-slate-200"><Icon name="Settings" size={20} /></button>
                        </div>
                    </header>

                    <div className="flex-1 flex overflow-hidden relative">
                        {/* 사이드바 */}
                        <aside className="w-64 bg-white border-r p-6 flex flex-col gap-4 z-10 shadow-sm">
                            <button onClick={addNode} className="w-full bg-slate-900 text-white py-4 rounded-2xl font-bold flex items-center justify-center gap-2 shadow-xl active:scale-95 transition-all hover:bg-black">
                                <Icon name="Plus" size={20} /> 새 블록 추가
                            </button>
                            <div className="mt-4 p-4 bg-indigo-50 rounded-2xl border border-indigo-100">
                                <p className="text-[10px] font-black text-indigo-400 uppercase tracking-widest mb-2">Status</p>
                                <div className="flex items-center gap-2">
                                    <div className={`w-2 h-2 rounded-full ${isAiLoading ? 'bg-amber-500 animate-pulse' : 'bg-emerald-500'}`}></div>
                                    <span className="text-xs font-bold text-slate-700">{isAiLoading ? 'AI 실행 중' : '준비 완료'}</span>
                                </div>
                            </div>
                        </aside>

                        {/* 캔버스 영역 */}
                        <main className="flex-1 relative bg-slate-100/50 overflow-hidden" onMouseDown={() => setConnectionSource(null)}>
                            <div className="absolute inset-0 opacity-[0.03] pointer-events-none" style={{backgroundImage: 'radial-gradient(#000 1px, transparent 1px)', backgroundSize: '30px 30px'}}></div>
                            
                            <svg className="absolute inset-0 w-full h-full pointer-events-none">
                                <defs>
                                    <marker id="arrow" markerWidth="10" markerHeight="10" refX="9" refY="5" orient="auto">
                                        <path d="M0,0 L10,5 L0,10 Z" fill="#cbd5e1" />
                                    </marker>
                                </defs>
                                {connections.map((c, i) => {
                                    const f = nodes.find(n => n.id === c.from);
                                    const t = nodes.find(n => n.id === c.to);
                                    if(!f || !t) return null;
                                    return <path key={i} d={getCurvePath(f.x + 224, f.y + 60, t.x, t.y + 60)} fill="none" stroke="#cbd5e1" strokeWidth="2" className="connection-line" markerEnd="url(#arrow)" />;
                                })}
                            </svg>

                            {nodes.map(node => (
                                <div key={node.id} 
                                     onMouseDown={(e) => onMouseDown(e, node.id)}
                                     onClick={(e) => { e.stopPropagation(); handleNodeClick(node.id); }}
                                     className={`absolute w-56 glass-card rounded-[2rem] p-6 shadow-sm border-2 transition-all cursor-grab active:cursor-grabbing node-glow 
                                     ${connectionSource === node.id ? 'border-amber-400 ring-4 ring-amber-50' : 'border-transparent hover:border-indigo-400'}`} 
                                     style={{left: node.x, top: node.y}}>
                                    <div className="flex justify-between items-center mb-4">
                                        <span className={`text-[9px] font-black px-2 py-1 rounded-lg uppercase tracking-widest ${node.status === 'processing' ? 'bg-amber-100 text-amber-600' : 'bg-slate-100 text-slate-400'}`}>
                                            {node.status}
                                        </span>
                                        <div className="flex gap-1">
                                            <button onClick={(e) => { e.stopPropagation(); setConnectionSource(node.id); }} className="btn-action p-2 hover:bg-amber-50 text-amber-500 rounded-lg transition-all" title="연결">
                                                <Icon name="Link2" size={14} />
                                            </button>
                                            {node.type === 'Input' && (
                                                <button onClick={(e) => { e.stopPropagation(); runGemini(node.id); }} disabled={isAiLoading} className="btn-action p-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 shadow-lg disabled:opacity-50 transition-all">
                                                    <Icon name={isAiLoading ? "Loader2" : "Play"} size={14} className={isAiLoading ? "animate-spin" : ""} fill={isAiLoading ? "none" : "white"} />
                                                </button>
                                            )}
                                        </div>
                                    </div>
                                    <h4 className="font-black text-[10px] text-indigo-600 uppercase mb-2 tracking-widest">{node.type}</h4>
                                    <textarea 
                                        className="w-full bg-transparent text-[11px] font-medium text-slate-700 leading-relaxed outline-none resize-none h-28 border-none p-0"
                                        value={node.content}
                                        onChange={(e) => updateNodeContent(node.id, e.target.value)}
                                        onMouseDown={(e) => e.stopPropagation()}
                                    />
                                </div>
                            ))}
                        </main>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
